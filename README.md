# C-philosophers-study
철학자로 배우는 프로세스/스레드

### mutex
> pthread_mutex_lock, pthread_mutex_unlock 사용, 객체입니당
- 포크를 잡을 수 있으면 1, 이미 다른 philo가 잡았다면 0의 상태로 지정해 둔다
- 동시에 같은 fork를 집는걸 방지하도록 (니가 먼저 놔라 한무 대기 -> 데드락)
- 어느 한 스레드가 공유변수를 이용하고 있다면, 다른 스레드에서 이 공유변수에 접근하지 못하도록 막아야한다
- 홀 / 짝 수의 philo들이 먼저 지정된 방향(왼 / 오)의 포크를 집는다
- 반환이 끝났을 때, 다음 동작을 수행하도록 한다
- critical section을 방지할 순 있지만, 이것만 사용한다면 일정 횟수를 반복했을 때 운없게 계속 못먹는 새기가 생겨 기아현상이 나타날 수 있다
- 추가적으로 모니터링이 필요하다

### monitoring
> 각각의 스레드가 제대로 작동하고 있는가?
- 모니터 스레드를 따로 생성
- 무한 루프를 도는 케이스들에 대해 대비 -> 죽었음 살앗음?
- 1. 모든 철학자가 죽음? 살음? 판별
- 2. 각각의 철학자의 최소 횟수의 식사가 보장되었는지 감시

### 함수 간단 정리!
- pthread_detach 함수 
	실행중인 쓰데드를 분리 상태로 만든다 
	간단하게 쓰레드를 메인쓰레드에서 분리 시킨다
	쓰레드가 종료되면, 모든 자원은 free하는 것을 보장한다
	성공하면 0, 실패하면 0이 아닌 다른 값 리턴
-  pthread_join
	쓰레드가 종료되는 것을 기다린다
	pthread_create, pthread_detach 함수를 통한 쓰레드는 join으로 기다릴수 없다
	joinable 쓰레드가 종료되었을 경우 메모리 자원을 free하지 않는다
	그래서  pthread_join로 호출해주어야 한다
	성공하면 0, 실패하면 0이 아닌 에러코드 반환
- pthread_mutex_init
	뮤텍스는 쓰레드가 공유하는 영역을 위해서 사용되는 도구, 이 함수는 뮤택스 객체를 초기화 시키기 위해서 사용한다
	뮤텍스는 fast, recurisve, error checking의 3가지 종류중 하나를 선택할 수 있다
	기본적으로 fast 사용
- pthread_mutex_destroy
	뮤텍스 객체를 삭제하고, 자원을 free한다
	성공하면 0, 실패시 0이 아닌 에러코드 반환
-  pthread_mutex_lock
	뮤텍스의 잠금을 요청한다 
	다른 쓰레드가 잠금을 얻을상태라면, 잠금을 얻을 수 있을 때 까지 기다리게된다
	뮤텍스의 최근상태가 unlock이라면 쓰레드는 잠금상태가 되고, 임계영역에 진입하게 되고 리턴한다
	성공하면 0,
	오류 리턴값은 아래와 같다 
		EINVAL  : 뮤텍스가 잘못 초기화됨
    	EDEADLK : 이미 잠금을 얻은 쓰레드가 다시 잠금을 요청할 때(errorchecking 뮤텍스일 경우 사용가능) 
-  pthread_mutex_unlock	
	잠금 상태를 해제한다
	만약 fast 뮤텍스라면, 언제나 unlock상태를 되돌려준다.
	recursive 뮤텍스는 잠겨있는 뮤텍스의 수를 감소시키고 이 수가 0이 되면 잠금을 해제한다


### 철학자 루틴

```
	thinking - 특별한 거 없이 과제에서 요구한 거에 맞춰서 출력
	pickup porks - 양쪽에 있는 공유자원인 포크를 드는 행위
	eating - 밥을 먹었으니 죽을 시간을 갱신, 먹은 횟수 체크, 포크를 내려놓는 행위
	sleep - 잠
```

### detatch vs join

- detatch : 인자의 스레드를 받아 메인 스레드로부터 분리, 종료 시 자원 자동 반환
- join : 인자의 스레드가 스레드 종료 시 자원을 반납할 때까지 기다린다.

> 두 함수 모두 스레드 종료 시 할당 자원 반납을 보장하며, 성공 시 0을 return
> join은 쓰레드가 끝나기 전까지 main 쓰레드가 동작할 수 없게 만들고, detach는 동작할 수 있게 만든다 는 것이다.

